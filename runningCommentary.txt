1. You asked for simple checkout functionality, and hinted that real input from a customer was required.

So I give you the capability of producing a price given a list of strings, presumably harvested off standard input dutifully typed in by the checkout operator on an old 70's teletype.

Rather than speculate on the nature of the IO system, let's focus on what we can test - take some strings and output a price.

You fixed the items and prices and this is going to be written in a short iteration - so no need to worry about configuration.

I would suggest the following tests:-

i) no items purchased means no bill - (OK, a bill of zero).

ii) one item purchased means the customer pays the price of that item - so what is that price? If I want to test for this, the test has to either have knowledge of the prices burnt into 'Checkout' - which is violating DRY, or I have to expose the prices as named values - Checkout.applePrice, Checkout.orangePrice - better, but not nice due due to the coupling and fiddling in the test to cover the two things. Why not just pass the prices in as mapped values - if I work to keep the test logic simple, this might actually be easier than having explicit constants. Or should I have modelled fruit as a union type with a price property - still a bit messy to test, and messier to extend without active patterns? Map and be damned!
Hmmm - now that I have used Scalacheck I think it would have been easy to use a union type or plain old class hierarchy with runtime binding. OTOH, I can imagine this might change if the business wants to add more items - but then a class hierarchy or active patterns would work. Oh well.

iii) if I purchase N items (could be the same ones repeated, maybe all in a bunch, maybe not), then the customer pays the sum of the bill for the first N-1 plus the price of the Nth item.

Time to Scalacheck - this how I would do things in reality. This is going to blow my time budget, but you as well find out how I work in practice ... I always prefer to stop and up my game to just coding fast.

iv) As a sanity check, a customer would expect that regardless of how they give the items to the checkout person, they get the same bill in all circumstances.

v) WON'T DO - suppose an item was entered when it shouldn't have by the checkout person (or the customer changed their mind). Should there be a may of cancelling the last item, or the last apple or orange?

vi) Hang on, bills can't be negative if I don't have any reedemable offers or cashback.

vii) Whoah - the checkout person might not always bother to CaptiTalise correctly. Hang on, the items are *scanned*. Let's just assume they always scan correctly, so no test for now. WON'T DO.

viii) Thinking about having to test using a price map made me think about what happens if there are more than just apples and oranges (which are not the only fruit). I don't care ... the customer only cares about
apples and oranges, so I don't have to define behaviour for lemons yet - that can wait. Only can it? Suppose instead of "lemon" the checkout person types 'applemon'? What then? Again, see point vii - WON'T DO.

ix) The business owner made an example bill - shouldn't this be tested as an acceptance test of sorts?

ASSUMPTION: work in integral pounds, so pence are fractional - do you pay 102p or £1.02?

ASSUMPTION: the original specification had positive prices - so forget about testing (and thinking about the implications of) negative prices in the item map.

If I am going to use the same itemMap in the tests for a sequence of operations, why don't I express this as a curried signature in Checkout.apply?

At this point I'm happy that I've achieved the spec - only there is no mention of apples or oranges in the tests. That is because it doesn't really matter - I submit that it was just as easy to test with an item map.

I do need to supply a 'production item map', though...where to put it? For now, I'll lump it in the checkout and walk away ... there are ways of refactoring the dependency on the item map, say be DI or by using an abstract baseclass - or by just passing the thing from somewhere else. Depends on what the customer wants, let's stop now.

